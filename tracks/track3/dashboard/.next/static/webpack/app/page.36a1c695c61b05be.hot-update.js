"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/api.ts":
/*!********************!*\
  !*** ./lib/api.ts ***!
  \********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fetchBloodInventory: function() { return /* binding */ fetchBloodInventory; },\n/* harmony export */   fetchDashboardData: function() { return /* binding */ fetchDashboardData; },\n/* harmony export */   fetchDashboardMetrics: function() { return /* binding */ fetchDashboardMetrics; },\n/* harmony export */   fetchForecasts: function() { return /* binding */ fetchForecasts; },\n/* harmony export */   fetchOptimizationRecommendations: function() { return /* binding */ fetchOptimizationRecommendations; }\n/* harmony export */ });\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! axios */ \"(app-pages-browser)/./node_modules/axios/lib/axios.js\");\n\n// API Configuration\nconst DATA_API_URL = \"http://localhost:8000\" || 0;\nconst FORECAST_API_URL = \"http://localhost:8001\" || 0;\nconst OPTIMIZATION_API_URL = \"http://localhost:8002\" || 0;\n// Create axios instances with default configurations\nconst dataApi = axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].create({\n    baseURL: DATA_API_URL,\n    timeout: 10000,\n    headers: {\n        \"Content-Type\": \"application/json\"\n    }\n});\nconst forecastApi = axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].create({\n    baseURL: FORECAST_API_URL,\n    timeout: 15000,\n    headers: {\n        \"Content-Type\": \"application/json\"\n    }\n});\nconst optimizationApi = axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].create({\n    baseURL: OPTIMIZATION_API_URL,\n    timeout: 10000,\n    headers: {\n        \"Content-Type\": \"application/json\"\n    }\n});\n// Add request interceptors for authentication if needed\nconst addAuthToken = (config)=>{\n    const token = localStorage.getItem(\"auth_token\");\n    if (token) {\n        config.headers.Authorization = \"Bearer \".concat(token);\n    }\n    return config;\n};\ndataApi.interceptors.request.use(addAuthToken);\nforecastApi.interceptors.request.use(addAuthToken);\noptimizationApi.interceptors.request.use(addAuthToken);\n// API Functions\nconst fetchDashboardMetrics = async ()=>{\n    try {\n        const response = await dataApi.get(\"/dashboard/metrics\");\n        return response.data;\n    } catch (error) {\n        console.error(\"Error fetching dashboard metrics:\", error);\n        throw new Error(\"Failed to fetch dashboard metrics\");\n    }\n};\nconst fetchBloodInventory = async ()=>{\n    try {\n        const response = await dataApi.get(\"/inventory\");\n        return response.data;\n    } catch (error) {\n        console.error(\"Error fetching blood inventory:\", error);\n        throw new Error(\"Failed to fetch blood inventory\");\n    }\n};\nconst fetchForecasts = async function() {\n    let days = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 7;\n    try {\n        // Fetch forecasts for all blood types\n        const bloodTypes = [\n            \"A+\",\n            \"A-\",\n            \"B+\",\n            \"B-\",\n            \"AB+\",\n            \"AB-\",\n            \"O+\",\n            \"O-\"\n        ];\n        const forecastPromises = bloodTypes.map(async (bloodType)=>{\n            try {\n                const response = await forecastApi.get(\"/forecast/\".concat(bloodType, \"?periods=\").concat(days));\n                return response.data.forecasts.map((f)=>({\n                        blood_type: bloodType,\n                        date: f.date,\n                        predicted_demand: f.predicted_demand,\n                        confidence_interval_lower: f.lower_bound,\n                        confidence_interval_upper: f.upper_bound\n                    }));\n            } catch (error) {\n                console.error(\"Error fetching forecast for \".concat(bloodType, \":\"), error);\n                return [];\n            }\n        });\n        const results = await Promise.all(forecastPromises);\n        return results.flat();\n    } catch (error) {\n        console.error(\"Error fetching forecasts:\", error);\n        // Return mock data for development\n        return generateMockForecasts(days);\n    }\n};\nconst fetchOptimizationRecommendations = async ()=>{\n    try {\n        const response = await optimizationApi.get(\"/recommendations/active\");\n        return response.data.recommendations || [];\n    } catch (error) {\n        console.error(\"Error fetching optimization recommendations:\", error);\n        // Return mock data for development\n        return generateMockRecommendations();\n    }\n};\nconst fetchDashboardData = async ()=>{\n    try {\n        const [metrics, inventory, forecasts, recommendations] = await Promise.all([\n            fetchDashboardMetrics(),\n            fetchBloodInventory(),\n            fetchForecasts(),\n            fetchOptimizationRecommendations()\n        ]);\n        // Process inventory data to extract blood types\n        const bloodTypes = processInventoryData(inventory);\n        // Generate alerts based on current data\n        const alerts = generateAlerts(bloodTypes, recommendations);\n        return {\n            metrics,\n            blood_types: bloodTypes,\n            forecasts,\n            recommendations,\n            alerts\n        };\n    } catch (error) {\n        console.error(\"Error fetching dashboard data:\", error);\n        // Return mock data for development\n        return generateMockDashboardData();\n    }\n};\n// Helper functions\nconst processInventoryData = (inventory)=>{\n    const bloodTypes = [\n        \"A+\",\n        \"A-\",\n        \"B+\",\n        \"B-\",\n        \"AB+\",\n        \"AB-\",\n        \"O+\",\n        \"O-\"\n    ];\n    return bloodTypes.map((type)=>{\n        const typeInventory = inventory.filter((item)=>item.blood_type === type);\n        const currentStock = typeInventory.length;\n        const safetyStock = 20 // Default safety stock\n        ;\n        const reorderPoint = 15 // Default reorder point\n        ;\n        let status;\n        if (currentStock <= 5) status = \"critical\";\n        else if (currentStock <= reorderPoint) status = \"low\";\n        else if (currentStock <= safetyStock * 1.5) status = \"adequate\";\n        else if (currentStock <= safetyStock * 2) status = \"optimal\";\n        else status = \"excess\";\n        return {\n            type: type,\n            current_stock: currentStock,\n            safety_stock: safetyStock,\n            reorder_point: reorderPoint,\n            days_until_expiry: Math.floor(Math.random() * 30) + 1,\n            status,\n            trend: [\n                \"increasing\",\n                \"decreasing\",\n                \"stable\"\n            ][Math.floor(Math.random() * 3)]\n        };\n    });\n};\nconst generateAlerts = (bloodTypes, recommendations)=>{\n    const alerts = [];\n    // Critical stock alerts\n    bloodTypes.forEach((bt)=>{\n        if (bt.status === \"critical\") {\n            alerts.push({\n                id: \"critical-\".concat(bt.type),\n                type: \"critical\",\n                title: \"Critical Stock Level\",\n                message: \"\".concat(bt.type, \" blood type has critically low stock (\").concat(bt.current_stock, \" units)\"),\n                blood_type: bt.type,\n                timestamp: new Date().toISOString(),\n                acknowledged: false\n            });\n        }\n    });\n    // Emergency recommendations\n    recommendations.forEach((rec)=>{\n        if (rec.priority_level === \"emergency\") {\n            alerts.push({\n                id: \"emergency-\".concat(rec.recommendation_id),\n                type: \"critical\",\n                title: \"Emergency Order Required\",\n                message: rec.reasoning,\n                blood_type: rec.blood_type,\n                timestamp: rec.created_at,\n                acknowledged: false\n            });\n        }\n    });\n    return alerts;\n};\n// Mock data generators for development\nconst generateMockForecasts = (days)=>{\n    const bloodTypes = [\n        \"A+\",\n        \"A-\",\n        \"B+\",\n        \"B-\",\n        \"AB+\",\n        \"AB-\",\n        \"O+\",\n        \"O-\"\n    ];\n    const forecasts = [];\n    bloodTypes.forEach((type)=>{\n        for(let i = 1; i <= days; i++){\n            const date = new Date();\n            date.setDate(date.getDate() + i);\n            const baseDemand = Math.random() * 20 + 10;\n            forecasts.push({\n                blood_type: type,\n                date: date.toISOString().split(\"T\")[0],\n                predicted_demand: baseDemand,\n                confidence_interval_lower: baseDemand * 0.8,\n                confidence_interval_upper: baseDemand * 1.2\n            });\n        }\n    });\n    return forecasts;\n};\nconst generateMockRecommendations = ()=>{\n    return [\n        {\n            recommendation_id: \"rec-001\",\n            blood_type: \"O+\",\n            current_stock_level: \"critical\",\n            recommendation_type: \"emergency_order\",\n            recommended_order_quantity: 50,\n            priority_level: \"emergency\",\n            cost_estimate: 6250,\n            expected_delivery_date: new Date(Date.now() + 3 * 24 * 60 * 60 * 1000).toISOString(),\n            reasoning: \"URGENT: Current stock (5) is below safety level (20).\",\n            confidence_score: 0.95,\n            created_at: new Date().toISOString()\n        }\n    ];\n};\nconst generateMockDashboardData = ()=>{\n    return {\n        metrics: {\n            total_donors: 1250,\n            total_donations_today: 15,\n            total_donations_this_month: 342,\n            total_inventory_units: 890,\n            units_expiring_soon: 23,\n            pending_requests: 8,\n            emergency_requests: 2,\n            blood_type_distribution: {\n                \"O+\": 180,\n                \"O-\": 45,\n                \"A+\": 150,\n                \"A-\": 38,\n                \"B+\": 120,\n                \"B-\": 32,\n                \"AB+\": 85,\n                \"AB-\": 22\n            },\n            component_distribution: {\n                \"whole_blood\": 450,\n                \"red_cells\": 280,\n                \"plasma\": 160\n            },\n            last_updated: new Date().toISOString()\n        },\n        blood_types: processInventoryData([]),\n        forecasts: generateMockForecasts(7),\n        recommendations: generateMockRecommendations(),\n        alerts: []\n    };\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O1lBQ2xCWixZQUFZLElBQUlQLE9BQU9DLFdBQVc7UUFDcEM7S0FDRDtBQUNIO0FBRUEsTUFBTTFCLDRCQUE0QjtJQUNoQyxPQUFPO1FBQ0xOLFNBQVM7WUFDUG1ELGNBQWM7WUFDZEMsdUJBQXVCO1lBQ3ZCQyw0QkFBNEI7WUFDNUJDLHVCQUF1QjtZQUN2QkMscUJBQXFCO1lBQ3JCQyxrQkFBa0I7WUFDbEJDLG9CQUFvQjtZQUNwQkMseUJBQXlCO2dCQUN2QixNQUFNO2dCQUFLLE1BQU07Z0JBQUksTUFBTTtnQkFBSyxNQUFNO2dCQUN0QyxNQUFNO2dCQUFLLE1BQU07Z0JBQUksT0FBTztnQkFBSSxPQUFPO1lBQ3pDO1lBQ0FDLHdCQUF3QjtnQkFDdEIsZUFBZTtnQkFBSyxhQUFhO2dCQUFLLFVBQVU7WUFDbEQ7WUFDQUMsY0FBYyxJQUFJN0IsT0FBT0MsV0FBVztRQUN0QztRQUNBM0IsYUFBYUgscUJBQXFCLEVBQUU7UUFDcENwQixXQUFXYSxzQkFBc0I7UUFDakNFLGlCQUFpQkM7UUFDakJLLFFBQVEsRUFBRTtJQUNaO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbGliL2FwaS50cz82OGExIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBheGlvcyBmcm9tICdheGlvcydcbmltcG9ydCB7IERhc2hib2FyZERhdGEsIERhc2hib2FyZE1ldHJpY3MsIEZvcmVjYXN0RGF0YSwgT3B0aW1pemF0aW9uUmVjb21tZW5kYXRpb24sIEFsZXJ0IH0gZnJvbSAnQC90eXBlcydcblxuLy8gQVBJIENvbmZpZ3VyYXRpb25cbmNvbnN0IERBVEFfQVBJX1VSTCA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0RBVEFfQVBJX1VSTCB8fCAnaHR0cDovL2xvY2FsaG9zdDo4MDAwJ1xuY29uc3QgRk9SRUNBU1RfQVBJX1VSTCA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0ZPUkVDQVNUX0FQSV9VUkwgfHwgJ2h0dHA6Ly9sb2NhbGhvc3Q6ODAwMSdcbmNvbnN0IE9QVElNSVpBVElPTl9BUElfVVJMID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfT1BUSU1JWkFUSU9OX0FQSV9VUkwgfHwgJ2h0dHA6Ly9sb2NhbGhvc3Q6ODAwMidcblxuLy8gQ3JlYXRlIGF4aW9zIGluc3RhbmNlcyB3aXRoIGRlZmF1bHQgY29uZmlndXJhdGlvbnNcbmNvbnN0IGRhdGFBcGkgPSBheGlvcy5jcmVhdGUoe1xuICBiYXNlVVJMOiBEQVRBX0FQSV9VUkwsXG4gIHRpbWVvdXQ6IDEwMDAwLFxuICBoZWFkZXJzOiB7XG4gICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgfSxcbn0pXG5cbmNvbnN0IGZvcmVjYXN0QXBpID0gYXhpb3MuY3JlYXRlKHtcbiAgYmFzZVVSTDogRk9SRUNBU1RfQVBJX1VSTCxcbiAgdGltZW91dDogMTUwMDAsXG4gIGhlYWRlcnM6IHtcbiAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICB9LFxufSlcblxuY29uc3Qgb3B0aW1pemF0aW9uQXBpID0gYXhpb3MuY3JlYXRlKHtcbiAgYmFzZVVSTDogT1BUSU1JWkFUSU9OX0FQSV9VUkwsXG4gIHRpbWVvdXQ6IDEwMDAwLFxuICBoZWFkZXJzOiB7XG4gICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgfSxcbn0pXG5cbi8vIEFkZCByZXF1ZXN0IGludGVyY2VwdG9ycyBmb3IgYXV0aGVudGljYXRpb24gaWYgbmVlZGVkXG5jb25zdCBhZGRBdXRoVG9rZW4gPSAoY29uZmlnOiBhbnkpID0+IHtcbiAgY29uc3QgdG9rZW4gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnYXV0aF90b2tlbicpXG4gIGlmICh0b2tlbikge1xuICAgIGNvbmZpZy5oZWFkZXJzLkF1dGhvcml6YXRpb24gPSBgQmVhcmVyICR7dG9rZW59YFxuICB9XG4gIHJldHVybiBjb25maWdcbn1cblxuZGF0YUFwaS5pbnRlcmNlcHRvcnMucmVxdWVzdC51c2UoYWRkQXV0aFRva2VuKVxuZm9yZWNhc3RBcGkuaW50ZXJjZXB0b3JzLnJlcXVlc3QudXNlKGFkZEF1dGhUb2tlbilcbm9wdGltaXphdGlvbkFwaS5pbnRlcmNlcHRvcnMucmVxdWVzdC51c2UoYWRkQXV0aFRva2VuKVxuXG4vLyBBUEkgRnVuY3Rpb25zXG5leHBvcnQgY29uc3QgZmV0Y2hEYXNoYm9hcmRNZXRyaWNzID0gYXN5bmMgKCk6IFByb21pc2U8RGFzaGJvYXJkTWV0cmljcz4gPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZGF0YUFwaS5nZXQoJy9kYXNoYm9hcmQvbWV0cmljcycpXG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGFcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBkYXNoYm9hcmQgbWV0cmljczonLCBlcnJvcilcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBmZXRjaCBkYXNoYm9hcmQgbWV0cmljcycpXG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGZldGNoQmxvb2RJbnZlbnRvcnkgPSBhc3luYyAoKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBkYXRhQXBpLmdldCgnL2ludmVudG9yeScpXG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGFcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBibG9vZCBpbnZlbnRvcnk6JywgZXJyb3IpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZmV0Y2ggYmxvb2QgaW52ZW50b3J5JylcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgZmV0Y2hGb3JlY2FzdHMgPSBhc3luYyAoZGF5czogbnVtYmVyID0gNyk6IFByb21pc2U8Rm9yZWNhc3REYXRhW10+ID0+IHtcbiAgdHJ5IHtcbiAgICAvLyBGZXRjaCBmb3JlY2FzdHMgZm9yIGFsbCBibG9vZCB0eXBlc1xuICAgIGNvbnN0IGJsb29kVHlwZXMgPSBbJ0ErJywgJ0EtJywgJ0IrJywgJ0ItJywgJ0FCKycsICdBQi0nLCAnTysnLCAnTy0nXVxuICAgIGNvbnN0IGZvcmVjYXN0UHJvbWlzZXMgPSBibG9vZFR5cGVzLm1hcChhc3luYyAoYmxvb2RUeXBlKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZvcmVjYXN0QXBpLmdldChgL2ZvcmVjYXN0LyR7Ymxvb2RUeXBlfT9wZXJpb2RzPSR7ZGF5c31gKVxuICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YS5mb3JlY2FzdHMubWFwKChmOiBhbnkpID0+ICh7XG4gICAgICAgICAgYmxvb2RfdHlwZTogYmxvb2RUeXBlLFxuICAgICAgICAgIGRhdGU6IGYuZGF0ZSxcbiAgICAgICAgICBwcmVkaWN0ZWRfZGVtYW5kOiBmLnByZWRpY3RlZF9kZW1hbmQsXG4gICAgICAgICAgY29uZmlkZW5jZV9pbnRlcnZhbF9sb3dlcjogZi5sb3dlcl9ib3VuZCxcbiAgICAgICAgICBjb25maWRlbmNlX2ludGVydmFsX3VwcGVyOiBmLnVwcGVyX2JvdW5kLFxuICAgICAgICB9KSlcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGZldGNoaW5nIGZvcmVjYXN0IGZvciAke2Jsb29kVHlwZX06YCwgZXJyb3IpXG4gICAgICAgIHJldHVybiBbXVxuICAgICAgfVxuICAgIH0pXG5cbiAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGwoZm9yZWNhc3RQcm9taXNlcylcbiAgICByZXR1cm4gcmVzdWx0cy5mbGF0KClcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBmb3JlY2FzdHM6JywgZXJyb3IpXG4gICAgLy8gUmV0dXJuIG1vY2sgZGF0YSBmb3IgZGV2ZWxvcG1lbnRcbiAgICByZXR1cm4gZ2VuZXJhdGVNb2NrRm9yZWNhc3RzKGRheXMpXG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGZldGNoT3B0aW1pemF0aW9uUmVjb21tZW5kYXRpb25zID0gYXN5bmMgKCk6IFByb21pc2U8T3B0aW1pemF0aW9uUmVjb21tZW5kYXRpb25bXT4gPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgb3B0aW1pemF0aW9uQXBpLmdldCgnL3JlY29tbWVuZGF0aW9ucy9hY3RpdmUnKVxuICAgIHJldHVybiByZXNwb25zZS5kYXRhLnJlY29tbWVuZGF0aW9ucyB8fCBbXVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIG9wdGltaXphdGlvbiByZWNvbW1lbmRhdGlvbnM6JywgZXJyb3IpXG4gICAgLy8gUmV0dXJuIG1vY2sgZGF0YSBmb3IgZGV2ZWxvcG1lbnRcbiAgICByZXR1cm4gZ2VuZXJhdGVNb2NrUmVjb21tZW5kYXRpb25zKClcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgZmV0Y2hEYXNoYm9hcmREYXRhID0gYXN5bmMgKCk6IFByb21pc2U8RGFzaGJvYXJkRGF0YT4gPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IFttZXRyaWNzLCBpbnZlbnRvcnksIGZvcmVjYXN0cywgcmVjb21tZW5kYXRpb25zXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgIGZldGNoRGFzaGJvYXJkTWV0cmljcygpLFxuICAgICAgZmV0Y2hCbG9vZEludmVudG9yeSgpLFxuICAgICAgZmV0Y2hGb3JlY2FzdHMoKSxcbiAgICAgIGZldGNoT3B0aW1pemF0aW9uUmVjb21tZW5kYXRpb25zKCksXG4gICAgXSlcblxuICAgIC8vIFByb2Nlc3MgaW52ZW50b3J5IGRhdGEgdG8gZXh0cmFjdCBibG9vZCB0eXBlc1xuICAgIGNvbnN0IGJsb29kVHlwZXMgPSBwcm9jZXNzSW52ZW50b3J5RGF0YShpbnZlbnRvcnkpXG4gICAgXG4gICAgLy8gR2VuZXJhdGUgYWxlcnRzIGJhc2VkIG9uIGN1cnJlbnQgZGF0YVxuICAgIGNvbnN0IGFsZXJ0cyA9IGdlbmVyYXRlQWxlcnRzKGJsb29kVHlwZXMsIHJlY29tbWVuZGF0aW9ucylcblxuICAgIHJldHVybiB7XG4gICAgICBtZXRyaWNzLFxuICAgICAgYmxvb2RfdHlwZXM6IGJsb29kVHlwZXMsXG4gICAgICBmb3JlY2FzdHMsXG4gICAgICByZWNvbW1lbmRhdGlvbnMsXG4gICAgICBhbGVydHMsXG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIGRhc2hib2FyZCBkYXRhOicsIGVycm9yKVxuICAgIC8vIFJldHVybiBtb2NrIGRhdGEgZm9yIGRldmVsb3BtZW50XG4gICAgcmV0dXJuIGdlbmVyYXRlTW9ja0Rhc2hib2FyZERhdGEoKVxuICB9XG59XG5cbi8vIEhlbHBlciBmdW5jdGlvbnNcbmNvbnN0IHByb2Nlc3NJbnZlbnRvcnlEYXRhID0gKGludmVudG9yeTogYW55KSA9PiB7XG4gIGNvbnN0IGJsb29kVHlwZXMgPSBbJ0ErJywgJ0EtJywgJ0IrJywgJ0ItJywgJ0FCKycsICdBQi0nLCAnTysnLCAnTy0nXVxuICBcbiAgcmV0dXJuIGJsb29kVHlwZXMubWFwKHR5cGUgPT4ge1xuICAgIGNvbnN0IHR5cGVJbnZlbnRvcnkgPSBpbnZlbnRvcnkuZmlsdGVyKChpdGVtOiBhbnkpID0+IGl0ZW0uYmxvb2RfdHlwZSA9PT0gdHlwZSlcbiAgICBjb25zdCBjdXJyZW50U3RvY2sgPSB0eXBlSW52ZW50b3J5Lmxlbmd0aFxuICAgIGNvbnN0IHNhZmV0eVN0b2NrID0gMjAgLy8gRGVmYXVsdCBzYWZldHkgc3RvY2tcbiAgICBjb25zdCByZW9yZGVyUG9pbnQgPSAxNSAvLyBEZWZhdWx0IHJlb3JkZXIgcG9pbnRcbiAgICBcbiAgICBsZXQgc3RhdHVzOiAnY3JpdGljYWwnIHwgJ2xvdycgfCAnYWRlcXVhdGUnIHwgJ29wdGltYWwnIHwgJ2V4Y2VzcydcbiAgICBpZiAoY3VycmVudFN0b2NrIDw9IDUpIHN0YXR1cyA9ICdjcml0aWNhbCdcbiAgICBlbHNlIGlmIChjdXJyZW50U3RvY2sgPD0gcmVvcmRlclBvaW50KSBzdGF0dXMgPSAnbG93J1xuICAgIGVsc2UgaWYgKGN1cnJlbnRTdG9jayA8PSBzYWZldHlTdG9jayAqIDEuNSkgc3RhdHVzID0gJ2FkZXF1YXRlJ1xuICAgIGVsc2UgaWYgKGN1cnJlbnRTdG9jayA8PSBzYWZldHlTdG9jayAqIDIpIHN0YXR1cyA9ICdvcHRpbWFsJ1xuICAgIGVsc2Ugc3RhdHVzID0gJ2V4Y2VzcydcblxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiB0eXBlIGFzIGFueSxcbiAgICAgIGN1cnJlbnRfc3RvY2s6IGN1cnJlbnRTdG9jayxcbiAgICAgIHNhZmV0eV9zdG9jazogc2FmZXR5U3RvY2ssXG4gICAgICByZW9yZGVyX3BvaW50OiByZW9yZGVyUG9pbnQsXG4gICAgICBkYXlzX3VudGlsX2V4cGlyeTogTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMzApICsgMSxcbiAgICAgIHN0YXR1cyxcbiAgICAgIHRyZW5kOiBbJ2luY3JlYXNpbmcnLCAnZGVjcmVhc2luZycsICdzdGFibGUnXVtNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAzKV0gYXMgYW55LFxuICAgIH1cbiAgfSlcbn1cblxuY29uc3QgZ2VuZXJhdGVBbGVydHMgPSAoYmxvb2RUeXBlczogYW55W10sIHJlY29tbWVuZGF0aW9uczogT3B0aW1pemF0aW9uUmVjb21tZW5kYXRpb25bXSk6IEFsZXJ0W10gPT4ge1xuICBjb25zdCBhbGVydHM6IEFsZXJ0W10gPSBbXVxuICBcbiAgLy8gQ3JpdGljYWwgc3RvY2sgYWxlcnRzXG4gIGJsb29kVHlwZXMuZm9yRWFjaChidCA9PiB7XG4gICAgaWYgKGJ0LnN0YXR1cyA9PT0gJ2NyaXRpY2FsJykge1xuICAgICAgYWxlcnRzLnB1c2goe1xuICAgICAgICBpZDogYGNyaXRpY2FsLSR7YnQudHlwZX1gLFxuICAgICAgICB0eXBlOiAnY3JpdGljYWwnLFxuICAgICAgICB0aXRsZTogJ0NyaXRpY2FsIFN0b2NrIExldmVsJyxcbiAgICAgICAgbWVzc2FnZTogYCR7YnQudHlwZX0gYmxvb2QgdHlwZSBoYXMgY3JpdGljYWxseSBsb3cgc3RvY2sgKCR7YnQuY3VycmVudF9zdG9ja30gdW5pdHMpYCxcbiAgICAgICAgYmxvb2RfdHlwZTogYnQudHlwZSxcbiAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIGFja25vd2xlZGdlZDogZmFsc2UsXG4gICAgICB9KVxuICAgIH1cbiAgfSlcblxuICAvLyBFbWVyZ2VuY3kgcmVjb21tZW5kYXRpb25zXG4gIHJlY29tbWVuZGF0aW9ucy5mb3JFYWNoKHJlYyA9PiB7XG4gICAgaWYgKHJlYy5wcmlvcml0eV9sZXZlbCA9PT0gJ2VtZXJnZW5jeScpIHtcbiAgICAgIGFsZXJ0cy5wdXNoKHtcbiAgICAgICAgaWQ6IGBlbWVyZ2VuY3ktJHtyZWMucmVjb21tZW5kYXRpb25faWR9YCxcbiAgICAgICAgdHlwZTogJ2NyaXRpY2FsJyxcbiAgICAgICAgdGl0bGU6ICdFbWVyZ2VuY3kgT3JkZXIgUmVxdWlyZWQnLFxuICAgICAgICBtZXNzYWdlOiByZWMucmVhc29uaW5nLFxuICAgICAgICBibG9vZF90eXBlOiByZWMuYmxvb2RfdHlwZSxcbiAgICAgICAgdGltZXN0YW1wOiByZWMuY3JlYXRlZF9hdCxcbiAgICAgICAgYWNrbm93bGVkZ2VkOiBmYWxzZSxcbiAgICAgIH0pXG4gICAgfVxuICB9KVxuXG4gIHJldHVybiBhbGVydHNcbn1cblxuLy8gTW9jayBkYXRhIGdlbmVyYXRvcnMgZm9yIGRldmVsb3BtZW50XG5jb25zdCBnZW5lcmF0ZU1vY2tGb3JlY2FzdHMgPSAoZGF5czogbnVtYmVyKTogRm9yZWNhc3REYXRhW10gPT4ge1xuICBjb25zdCBibG9vZFR5cGVzID0gWydBKycsICdBLScsICdCKycsICdCLScsICdBQisnLCAnQUItJywgJ08rJywgJ08tJ11cbiAgY29uc3QgZm9yZWNhc3RzOiBGb3JlY2FzdERhdGFbXSA9IFtdXG4gIFxuICBibG9vZFR5cGVzLmZvckVhY2godHlwZSA9PiB7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gZGF5czsgaSsrKSB7XG4gICAgICBjb25zdCBkYXRlID0gbmV3IERhdGUoKVxuICAgICAgZGF0ZS5zZXREYXRlKGRhdGUuZ2V0RGF0ZSgpICsgaSlcbiAgICAgIFxuICAgICAgY29uc3QgYmFzZURlbWFuZCA9IE1hdGgucmFuZG9tKCkgKiAyMCArIDEwXG4gICAgICBmb3JlY2FzdHMucHVzaCh7XG4gICAgICAgIGJsb29kX3R5cGU6IHR5cGUsXG4gICAgICAgIGRhdGU6IGRhdGUudG9JU09TdHJpbmcoKS5zcGxpdCgnVCcpWzBdLFxuICAgICAgICBwcmVkaWN0ZWRfZGVtYW5kOiBiYXNlRGVtYW5kLFxuICAgICAgICBjb25maWRlbmNlX2ludGVydmFsX2xvd2VyOiBiYXNlRGVtYW5kICogMC44LFxuICAgICAgICBjb25maWRlbmNlX2ludGVydmFsX3VwcGVyOiBiYXNlRGVtYW5kICogMS4yLFxuICAgICAgfSlcbiAgICB9XG4gIH0pXG4gIFxuICByZXR1cm4gZm9yZWNhc3RzXG59XG5cbmNvbnN0IGdlbmVyYXRlTW9ja1JlY29tbWVuZGF0aW9ucyA9ICgpOiBPcHRpbWl6YXRpb25SZWNvbW1lbmRhdGlvbltdID0+IHtcbiAgcmV0dXJuIFtcbiAgICB7XG4gICAgICByZWNvbW1lbmRhdGlvbl9pZDogJ3JlYy0wMDEnLFxuICAgICAgYmxvb2RfdHlwZTogJ08rJyxcbiAgICAgIGN1cnJlbnRfc3RvY2tfbGV2ZWw6ICdjcml0aWNhbCcsXG4gICAgICByZWNvbW1lbmRhdGlvbl90eXBlOiAnZW1lcmdlbmN5X29yZGVyJyxcbiAgICAgIHJlY29tbWVuZGVkX29yZGVyX3F1YW50aXR5OiA1MCxcbiAgICAgIHByaW9yaXR5X2xldmVsOiAnZW1lcmdlbmN5JyxcbiAgICAgIGNvc3RfZXN0aW1hdGU6IDYyNTAsXG4gICAgICBleHBlY3RlZF9kZWxpdmVyeV9kYXRlOiBuZXcgRGF0ZShEYXRlLm5vdygpICsgMyAqIDI0ICogNjAgKiA2MCAqIDEwMDApLnRvSVNPU3RyaW5nKCksXG4gICAgICByZWFzb25pbmc6ICdVUkdFTlQ6IEN1cnJlbnQgc3RvY2sgKDUpIGlzIGJlbG93IHNhZmV0eSBsZXZlbCAoMjApLicsXG4gICAgICBjb25maWRlbmNlX3Njb3JlOiAwLjk1LFxuICAgICAgY3JlYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgIH0sXG4gIF1cbn1cblxuY29uc3QgZ2VuZXJhdGVNb2NrRGFzaGJvYXJkRGF0YSA9ICgpOiBEYXNoYm9hcmREYXRhID0+IHtcbiAgcmV0dXJuIHtcbiAgICBtZXRyaWNzOiB7XG4gICAgICB0b3RhbF9kb25vcnM6IDEyNTAsXG4gICAgICB0b3RhbF9kb25hdGlvbnNfdG9kYXk6IDE1LFxuICAgICAgdG90YWxfZG9uYXRpb25zX3RoaXNfbW9udGg6IDM0MixcbiAgICAgIHRvdGFsX2ludmVudG9yeV91bml0czogODkwLFxuICAgICAgdW5pdHNfZXhwaXJpbmdfc29vbjogMjMsXG4gICAgICBwZW5kaW5nX3JlcXVlc3RzOiA4LFxuICAgICAgZW1lcmdlbmN5X3JlcXVlc3RzOiAyLFxuICAgICAgYmxvb2RfdHlwZV9kaXN0cmlidXRpb246IHtcbiAgICAgICAgJ08rJzogMTgwLCAnTy0nOiA0NSwgJ0ErJzogMTUwLCAnQS0nOiAzOCxcbiAgICAgICAgJ0IrJzogMTIwLCAnQi0nOiAzMiwgJ0FCKyc6IDg1LCAnQUItJzogMjJcbiAgICAgIH0sXG4gICAgICBjb21wb25lbnRfZGlzdHJpYnV0aW9uOiB7XG4gICAgICAgICd3aG9sZV9ibG9vZCc6IDQ1MCwgJ3JlZF9jZWxscyc6IDI4MCwgJ3BsYXNtYSc6IDE2MFxuICAgICAgfSxcbiAgICAgIGxhc3RfdXBkYXRlZDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgIH0sXG4gICAgYmxvb2RfdHlwZXM6IHByb2Nlc3NJbnZlbnRvcnlEYXRhKFtdKSxcbiAgICBmb3JlY2FzdHM6IGdlbmVyYXRlTW9ja0ZvcmVjYXN0cyg3KSxcbiAgICByZWNvbW1lbmRhdGlvbnM6IGdlbmVyYXRlTW9ja1JlY29tbWVuZGF0aW9ucygpLFxuICAgIGFsZXJ0czogW10sXG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJheGlvcyIsIkRBVEFfQVBJX1VSTCIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19EQVRBX0FQSV9VUkwiLCJGT1JFQ0FTVF9BUElfVVJMIiwiTkVYVF9QVUJMSUNfRk9SRUNBU1RfQVBJX1VSTCIsIk9QVElNSVpBVElPTl9BUElfVVJMIiwiTkVYVF9QVUJMSUNfT1BUSU1JWkFUSU9OX0FQSV9VUkwiLCJkYXRhQXBpIiwiY3JlYXRlIiwiYmFzZVVSTCIsInRpbWVvdXQiLCJoZWFkZXJzIiwiZm9yZWNhc3RBcGkiLCJvcHRpbWl6YXRpb25BcGkiLCJhZGRBdXRoVG9rZW4iLCJjb25maWciLCJ0b2tlbiIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJBdXRob3JpemF0aW9uIiwiaW50ZXJjZXB0b3JzIiwicmVxdWVzdCIsInVzZSIsImZldGNoRGFzaGJvYXJkTWV0cmljcyIsInJlc3BvbnNlIiwiZ2V0IiwiZGF0YSIsImVycm9yIiwiY29uc29sZSIsIkVycm9yIiwiZmV0Y2hCbG9vZEludmVudG9yeSIsImZldGNoRm9yZWNhc3RzIiwiZGF5cyIsImJsb29kVHlwZXMiLCJmb3JlY2FzdFByb21pc2VzIiwibWFwIiwiYmxvb2RUeXBlIiwiZm9yZWNhc3RzIiwiZiIsImJsb29kX3R5cGUiLCJkYXRlIiwicHJlZGljdGVkX2RlbWFuZCIsImNvbmZpZGVuY2VfaW50ZXJ2YWxfbG93ZXIiLCJsb3dlcl9ib3VuZCIsImNvbmZpZGVuY2VfaW50ZXJ2YWxfdXBwZXIiLCJ1cHBlcl9ib3VuZCIsInJlc3VsdHMiLCJQcm9taXNlIiwiYWxsIiwiZmxhdCIsImdlbmVyYXRlTW9ja0ZvcmVjYXN0cyIsImZldGNoT3B0aW1pemF0aW9uUmVjb21tZW5kYXRpb25zIiwicmVjb21tZW5kYXRpb25zIiwiZ2VuZXJhdGVNb2NrUmVjb21tZW5kYXRpb25zIiwiZmV0Y2hEYXNoYm9hcmREYXRhIiwibWV0cmljcyIsImludmVudG9yeSIsInByb2Nlc3NJbnZlbnRvcnlEYXRhIiwiYWxlcnRzIiwiZ2VuZXJhdGVBbGVydHMiLCJibG9vZF90eXBlcyIsImdlbmVyYXRlTW9ja0Rhc2hib2FyZERhdGEiLCJ0eXBlIiwidHlwZUludmVudG9yeSIsImZpbHRlciIsIml0ZW0iLCJjdXJyZW50U3RvY2siLCJsZW5ndGgiLCJzYWZldHlTdG9jayIsInJlb3JkZXJQb2ludCIsInN0YXR1cyIsImN1cnJlbnRfc3RvY2siLCJzYWZldHlfc3RvY2siLCJyZW9yZGVyX3BvaW50IiwiZGF5c191bnRpbF9leHBpcnkiLCJNYXRoIiwiZmxvb3IiLCJyYW5kb20iLCJ0cmVuZCIsImZvckVhY2giLCJidCIsInB1c2giLCJpZCIsInRpdGxlIiwibWVzc2FnZSIsInRpbWVzdGFtcCIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsImFja25vd2xlZGdlZCIsInJlYyIsInByaW9yaXR5X2xldmVsIiwicmVjb21tZW5kYXRpb25faWQiLCJyZWFzb25pbmciLCJjcmVhdGVkX2F0IiwiaSIsInNldERhdGUiLCJnZXREYXRlIiwiYmFzZURlbWFuZCIsInNwbGl0IiwiY3VycmVudF9zdG9ja19sZXZlbCIsInJlY29tbWVuZGF0aW9uX3R5cGUiLCJyZWNvbW1lbmRlZF9vcmRlcl9xdWFudGl0eSIsImNvc3RfZXN0aW1hdGUiLCJleHBlY3RlZF9kZWxpdmVyeV9kYXRlIiwibm93IiwiY29uZmlkZW5jZV9zY29yZSIsInRvdGFsX2Rvbm9ycyIsInRvdGFsX2RvbmF0aW9uc190b2RheSIsInRvdGFsX2RvbmF0aW9uc190aGlzX21vbnRoIiwidG90YWxfaW52ZW50b3J5X3VuaXRzIiwidW5pdHNfZXhwaXJpbmdfc29vbiIsInBlbmRpbmdfcmVxdWVzdHMiLCJlbWVyZ2VuY3lfcmVxdWVzdHMiLCJibG9vZF90eXBlX2Rpc3RyaWJ1dGlvbiIsImNvbXBvbmVudF9kaXN0cmlidXRpb24iLCJsYXN0X3VwZGF0ZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/api.ts\n"));

/***/ })

});